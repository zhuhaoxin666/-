### 一、数据结构基本知识

#### 1.基本概念和术语

+ **数据** ：对客观事物的符号表示，在计算机科学中是指能输入到计算机中并被计算机程序处理的符号的总称。

+ **数据元素** ：是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。有时，一个数据元素可由若干个**数据项**组成。例如，一本书的书目信息为一个数据元素，而书目信息中的每一项（如书名，作者）为一个**数据项**。

+ **数据对象** ：是性质相同的数据元素的集合，是数据的一个子集

  + 例如: 整数数据对象是集合N={0,+- 1, +- 2,...},字母字符数据对象是集合C={'A','B','C',...}

+ **数据结构** : 是相互之间存在一种或多种特定关系的数据元素的集合。

  + 通常有以下几种结构：
    + 集合
    + 线性结构：一对一
    + 树形结构：一对多
    + 图状结构或网状结构：多对多

+ **物理结构** ：数据结构在计算机中的表示（又称映像），物理结构也叫做存储结构

  + **数据域** ：当数据元素由若干数据项组成时，位串中对应于各个数据项的子位串称为**数据域**。
  + 数据元素之间的关系在计算机中有两种不同的表示方法：**顺序映像和非顺序映像**，由此得到：
    + 顺序存储结构
    + 链式存储结构

+ **抽象数据类型**（ADT）: 抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。

  + > ADT 抽象数据类型名{
    >
    > ​	数据对象：<数据对象的定义>
    >
    > ​	数据关系:   <数据关系的定义>
    >
    > ​	基本操作:   <基本操作的定义>
    >
    > }ADT 抽象数据类型名

  + 基本操作的定义

    + > 基本操作名（参数表）
      >
      > ​		初始条件：（初始条件描述）
      >
      > ​		操作结果：（操作结果描述）

#### 算法和算法分析

+ **算法特性**
  + **有穷性**：一个算法必须总是在执行有穷步骤之后结束，且每一步在有穷时间之内完成
  + **确定性**：算法的每一条指令必须有确切的含义，只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出
  + **可行性**：一个算法是能行的，即算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现的。
  + **输入**：一个算法要有零个或多个的输入
  + **输出**: 一个算法要有一个或多个的输出
+ **算法设计的要求**
  + **正确性**
  + **可读性**
  + **健壮性**
  + **效率与低存储量需求**
+ **算法效率的度量**
  + **时间复杂度**
  + **空间复杂度**



### 二、线性表

#### 1.链表

+ 特点：比数组灵活，插入删除方便，但失去了随机访问的能力。

+ 声明节点类型:

  + 

    ```c
    struct node {
    
        int val;
        struct node *next;
    
    };
    ```

  + ```c
    #include<stdio.h>
    #include<stdlib.h>
    
    typedef struct node {
    
        int val;
        struct node *next;
    
    } Node;
    
    int main() {
    
        //node所占空间
        int length = sizeof(struct node);
    
        Node *head = malloc(length);
        head->val = 0;
        int n = 0;
        scanf("%d", &n);
        //尾插法
        Node *p = head;
        for (int i = 0; i < n; i++) {
            Node *newNode = malloc(length);
            newNode->val = i;
            newNode->next=NULL;
            p->next = newNode;
            p = p->next;
        }
    
        head = head->next;
        
        //input : 5
        //output: 0 1 2 3 4
        while (head != NULL) {
            printf("%d ",head->val);
            head = head->next;
        }
        return 0;
    }
    ```

     	

  + ```c
    //删除节点
    
    #include<stdio.h>
    #include<stdlib.h>
    
    typedef struct node {
    
        int val;
        struct node *next;
    
    } Node;
    
    void printNode(Node *head){
        while(head!=NULL){
            printf("%d ",head->val);
            head = head->next;
        }
        printf("\n");
    }
    
    //删除值为val的node
    Node *deleteNode(Node *head,int val){
        Node *pre = head;
        Node *cur = head;
        while (cur!=NULL){
    
            //处理头节点是要删除的节点
            if(head->val == cur->val && cur->val == val){
                head = head->next;
            }
    
            if(cur->val == val){
                pre->next = cur->next;
            }
            pre = cur;
            cur = cur->next;
        }
        return head;
    }
    
    int main() {
    
        //node所占空间
        int length = sizeof(struct node);
    
        Node *head = malloc(length);
        head->val = 0;
        int n = 5;
        //尾插法
        Node *p = head;
        for (int i = 0; i < n; i++) {
            Node *newNode = malloc(length);
            newNode->val = i;
            newNode->next=NULL;
            p->next = newNode;
            p = p->next;
        }
    
        head = head->next;
    
        //input : 5
        //output: 0 1 2 3 4
        printf("delete before\n");
        printNode(head);
        printf("delete after\n");
        Node *res = deleteNode(head,0);
        printNode(res);
        return 0;
    }
    ```

#### 2.栈和队列

+ 栈：后入先出
+ 队列：先入先出
  + 循环队列



### 三、树和二叉树

+ 树的度：树的度为树种各个节点的度的最大值
+ 树的层数，从根开始 到最下层叶子，1，2 ，3...
+ 树的高度，深度就是层数

#### 树

+ 树的存储结构：

  + 双亲表示法：以数组来表示，给每个结点一个下标来一一对应

    + ```c
           a
         b   c
       d
      [a,b,c,d] 
       0 1 2 3
      根用-1为值，其他的用它的父亲的下标为值
               [-1,0,0,1]
      ```

  + 孩子表示法：

  + 孩子兄弟表示法

+ 森林和二叉树的转换

  + 树 -> 二叉树

    + 用二叉树的左孩子来表示孩子，右孩子来表示兄弟

      + ```c
        
        /*
                 A
               / | \
              B  C  E
                 |
                 D 
                     
           转换成：
                A
               /
              B
               \
                C
               / \
              D   E   
                     
         *** 所以，对于任意一颗树转换为二叉树之后，其根节点的右子树都为空
             若把森林中的第二棵树的根节点看成是第一颗树的兄弟，即可将森林转换为二叉树
          
         如下面这个森林：
          
           	 A               E             G
           / | \             |            / \
          B  C  D            F           H   I
                                             |
                                             J
          
          转换后：
          
          				A
          			   /  \	
                      B     E
                       \   /  \
                        C  F    G
                         \     /
                          D   H
                               \
                                I
                               /
                              J
          
          
          
          */        
        ```



+ 树和森林的遍历
  + 树的遍历
    + 先根遍历树：先访问树的根节点，然后再依次遍历根的每个子树
    + 后根遍历树：先依次后根遍历每颗子树，然后访问根结点
  + 森林的遍历
    + 先序遍历森林
    + 中序遍历森林
+ 赫夫曼数（最优二叉树）

#### 二叉树

+ 形态：5种基本形态
  + 空二叉树
  + 仅有根节点的二叉树
  + 仅有左孩子的二叉树
  + 仅有右孩子的二叉树
  + 左右孩子均非空的二叉树
+ 性质：
  + **在二叉树的第i层上至多有2^(i-1)个结点（i>=1）**
  + **深度为k的二叉树至多有2^k  -1 个结点（k>=1）**
  + **对任何一颗二叉树T，如果其叶子结点数为n0，度为2的结点数为n2，则n0 = n2+1**
+ 满二叉树：
  + 深度为k的二叉树，结点数为2^k -1 
+ 完全二叉树：
  + 叶子结点只可能出现在层次最大的两层上
  + 对任意结点，若其右分支下的子孙的最大层次为m，则其左分支下的子孙的最大层次必为m或m+1
  + **性质**：具有n个结点的完全二叉树的深度为 [log n] +1 ,[log n]向下取整
+ 二叉树的存储结构：
  + 顺序存储结构：一维数组表示，i的左孩子为2i，i的右孩子为2i+1
  + 链式存储结构
+ 遍历二叉树
  + 先序遍历（前序）：根、左、右
  + 中序遍历：左、根、右
  + 后序遍历：左、右、根
  + 层序遍历
+ 线索二叉树



### 四、图

+ 在图中的数据元素通常称为**顶点**

+ 有向图：

  ```c
  /*
  G1 = (V1,{A1})
  其中：
  V1 = {v1,v2,v3,v4}
  A1 = {<v1,v2>,<v1,v3>,<v3,v4>,<v4,v1>}
  
  */
  ```

+ 无向图

```c
/*

G2 = (V2{E2})
其中：
V2 = {v1,v2,v3,v4}
E2 = {(v1,v2),(v1,v3),(v3,v4),(v4,v1)}



*/
```

+ 完全图

  + 对于无向图，设有n个顶点，那么边的取值范围就是0 到 1/2 * n * (n-1)，若有1/2 * n * (n-1)条边，则是完全图。
  + 对于有向图，边的取值范围在 0 ~ n(n-1)，具有n(n-1)条边的有向图称为有向完全图，有很少条边（如 e < nlogn）的图称为稀疏图，反之称为稠密图。

+ 连通图

  + 对于图中任意两个顶点vi，vj，vi和vj都是连通的。
  + 连通分量，指的是无向图中的极大连通子图

+ 图的存储结构：

  + 邻接矩阵法

  + 邻接表

    + 用一个数组，下标对应顶点

    + ```c
      /*
      
      图G1：
            V1 ->  V2
            🡳  ↖
      	  V3 -> V4
      
          -------- 	 ------	   -----
      	|0|V1| | ->  |2|  | -> |1|^|
      	--------	 ------    -----
      	|1|V2|^| 
          -------- 	-----
          |2|V3| | -> |3|^|
          --------	-----
          |3|V4| | -> |0|^|
      	--------	-----
      
      */
      ```

  + 十字链表

  + 邻接多重表

+ 图的遍历

  + 深度优先搜索
  + 广度优先搜索

+ 最小生成树

  + 普利姆算法

+ 拓扑排序

+ 最短路径

  + 迪杰斯特拉算法
  + 弗洛伊德算法



### 五、文件和查找

#### 文件

+ 详解：

  <[数据结构——文件 - 程序员大本营 (pianshen.com)](https://www.pianshen.com/article/7798869249/)>

+ 定义：文件时由大量性质相同的记录组成的集合。
  + 可按类型分为两类：
    + 操作系统文件
    + 数据库文件
+ 文件的操作：
  + 检索
    + 顺序存取：存取下一个逻辑记录
    + 直接存取：存取第i个逻辑记录
    + 按关键字存取：给定一个值，查询一个或一批关键字与给定值相关的记录，对数据库文件可以有如下4种查询方式：
      + 简单查询
      + 区域查询
      + 函数查询
      + 布尔查询
  + 修改
+ 顺序文件：
  + 定义：是记录按其在文件中的逻辑顺序依次进入存储介质而建立的，即顺序文件中的物理记录的顺序和逻辑记录的顺序是一致的。又称连续文件。
+ 索引文件
+ ISAM文件和VSAM文件



#### 查找

+ 查找表：是由同一类型的数据元素（或记录）构成的集合。
+ 静态查找表
  + 顺序查找
  + 折半查找：至多比较 [logn] +1次，[logn]下取整



+ 动态查找表
  + 二叉搜索树的查找插入



###	六、内排序

+ 插入排序

  + 直接插入排序

    + 将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过。

    + ```python
      #直接插入排序
      def insert_sort(L):
          #遍历数组中的所有元素，其中0号索引元素默认已排序，因此从1开始
          for x in range(1,len(L)):
          #将该元素与已排序好的前序数组依次比较，如果该元素小，则交换
          #range(x-1,-1,-1):从x-1倒序循环到0
              for i in range(x-1,-1,-1):
          #判断：如果符合条件则交换
                  if L[i] > L[i+1]:
                      temp = L[i+1]
                      L[i+1] = L[i]
                      L[i] = temp
      ```

      

  + 希尔排序

    + 将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。
      同样的：从上面的描述中我们可以发现：希尔排序的总体实现应该由三个循环完成：

      1. 第一层循环：将gap依次折半，对序列进行分组，直到gap=1
      2. 第二、三层循环：也即直接插入排序所需要的两次循环。具体描述见上。

    + ```python
      #希尔排序
      def insert_shell(L):
          #初始化gap值，此处利用序列长度的一般为其赋值
          gap = (int)(len(L)/2)
          #第一层循环：依次改变gap值对列表进行分组
          while (gap >= 1):
          #下面：利用直接插入排序的思想对分组数据进行排序
          #range(gap,len(L)):从gap开始
              for x in range(gap,len(L)):
          #range(x-gap,-1,-gap):从x-gap开始与选定元素开始倒序比较，每个比较元素之间间隔gap
                  for i in range(x-gap,-1,-gap):
          #如果该组当中两个元素满足交换条件，则进行交换
                      if L[i] > L[i+gap]:
                          temp = L[i+gap]
                          L[i+gap] = L[i]
                          L[i] =temp
          #while循环条件折半
              gap = (int)(gap/2)
      ```

      

+ 选择排序

  + 简单选择排序

    + 简单选择排序的基本思想：比较+交换。

    + (1)从待排序序列中，找到关键字最小的元素；

    + (2)如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；

    + 从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。

    + ```python
      # 简单选择排序
      def select_sort(L):
      #依次遍历序列中的每一个元素
          for x in range(0,len(L)):
      #将当前位置的元素定义此轮循环当中的最小值
              minimum = L[x]
      #将该元素与剩下的元素依次比较寻找最小元素
              for i in range(x+1,len(L)):
                  if L[i] < minimum:
                      temp = L[i];
                      L[i] = minimum;
                      minimum = temp
      #将比较后得到的真正的最小值赋值给当前位置
              L[x] = minimum
      ```

      

  + 堆排序

+ 交换排序

  + 冒泡排序

    + 将序列当中的左右元素，依次比较，保证右边的元素始终大于左边的元素；
      （ 第一轮结束后，序列最后一个元素一定是当前序列的最大值；）

    + 对序列当中剩下的n-1个元素再次执行步骤1。

    + 对于长度为n的序列，一共需要执行n-1轮比较
      （利用while循环可以减少执行次数）

    + ```python
      #冒泡排序
      def bubble_sort(L):
          length = len(L)
      #序列长度为length，需要执行length-1轮交换
          for x in range(1,length):
      #对于每一轮交换，都将序列当中的左右元素进行比较
      #每轮交换当中，由于序列最后的元素一定是最大的，因此每轮循环到序列未排序的位置即可
              for i in range(0,length-x):
                  if L[i] > L[i+1]:
                      temp = L[i]
                      L[i] = L[i+1]
                      L[i+1] = temp
      ```

      

  + 快速排序

    + 从序列当中选择一个基准数(pivot)
      在这里我们选择序列当中第一个数最为基准数

    + 将序列当中的所有数依次遍历，比基准数大的位于其右侧，比基准数小的位于其左侧

    + 重复步骤1.2，直到所有子集当中只有一个元素为止。
      用伪代码描述如下：
      1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。
      2．j--由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。
      3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。
      4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中

    + ```python
      #快速排序
      #L：待排序的序列；start排序的开始index,end序列末尾的index
      #对于长度为length的序列：start = 0;end = length-1
      def quick_sort(L,start,end):
          if start < end:
              i , j , pivot = start , end , L[start]
              while i < j:
      #从右开始向左寻找第一个小于pivot的值
                  while (i < j) and (L[j] >= pivot):
                      j = j-1
      #将小于pivot的值移到左边
                  if (i < j):
                      L[i] = L[j]
                      i = i+1 
      #从左开始向右寻找第一个大于pivot的值
                  while (i < j) and (L[i] < pivot):
                      i = i+1
      #将大于pivot的值移到右边
                  if (i < j):
                      L[j] = L[i]
                      j = j-1
      #循环结束后，说明 i=j，此时左边的值全都小于pivot,右边的值全都大于pivot
      #pivot的位置移动正确，那么此时只需对左右两侧的序列调用此函数进一步排序即可
      #递归调用函数：依次对左侧序列：从0 ~ i-1//右侧序列：从i+1 ~ end
              L[i] = pivot
      #左侧序列继续排序
              quick_sort(L,start,i-1)
      #右侧序列继续排序
              quick_sort(L,i+1,end)
      ```

      

+ 归并排序

  + 分而治之，分到最小程度，排序，之后合并，再排序

+ 基数排序

  + 将数据统一为相同长度，长度不足的在之前补0，然后先按个位数，放置到0-9号”桶“里，然后再按十位排序，再按百位排序。。





+ 性能比较

|          |           |                       |          时间复杂度          |               | 空间复杂度 |        |
| :------: | :-------: | :-------------------: | :--------------------------: | :-----------: | :--------: | :----: |
|   类别   | 排序方式  |       平均情况        |           最好情况           |   最坏情况    |  辅助存储  | 稳定性 |
|          |           |                       |                              |               |            |        |
|          | 直接插入  |        O(n^2)         |             O(n)             |    O(n^2)     |    O(1)    |  稳定  |
| 插入排序 | shell排序 |       O(n^1.3)        |             O(n)             |    O(n^2)     |    O(1)    | 不稳定 |
|          |           |                       |                              |               |            |        |
|          | 直接选择  |        O(n^2)         |            O(n^2)            |    O(n^2)     |    O(1)    | 不稳定 |
| 选择排序 |  堆排序   |       O(nlogn)        |           O(nlogn)           |   O(nlogn)    |    O(1)    | 不稳定 |
|          |           |                       |                              |               |            |        |
|          | 冒泡排序  |        O(n^2)         |             O(n)             |    O(n^2)     |    O(1)    |  稳定  |
| 交换排序 | 快速排序  |       O(nlogn)        |           O(nlogn)           |    O(n^2)     |  O(nlogn)  | 不稳定 |
|          |           |                       |                              |               |            |        |
| 归并排序 |           |       O(nlogn)        |           O(nlogn)           |   O(nlogn)    |    O(1)    |  稳定  |
|          |           |                       |                              |               |            |        |
| 基数排序 |           |       O(d(n+r))       |          O(d(n+r))           |   O(d(n+r)    |  O(n+rd)   |  稳定  |
|          |           | r代表关键字的取值范围 | d代表桶个数（0-9的话就是10） | n代表数据个数 |            |        |