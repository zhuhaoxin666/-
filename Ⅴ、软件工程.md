### 一、概述

#### 1.什么是软件

+ 软件是程序和所有使程序正确运行所需要的相关文档和配置信息。
+ 分类
  + 通用软件产品
  + 定制软件产品

#### 2.什么是软件工程

+ 定义：
  + 软件工程是一门工程学科，涉及软件生产的各个方面，从最初的系统描述一直到使用后的系统维护，都属于该学科范畴。
+ 什么是软件过程：
  + 是指制作软件产品的一组活动及其结果。所有的软件过程都包含4项基本的活动
    + 软件描述
    + 软件开发
    + 软件有效性验证
    + 软件进化
+ 什么是软件过程模型
  + 工作流模型：该模型描述软件过程中各种活动的序列及其输入、输出和相互依赖性。其中活动皆为人的活动
  + 数据流或活动模型：该模型把软件过程描述成一组活动，其中每个活动都完成一定的数据转换。
  + 角色/动作模型：该模型描述了参与软件过程的人员的不同角色和他们各自负责的活动，绝大多数软件过程模型是基于如下三种通用软件开发模型或范型的：
    + 瀑布模型
    + 迭代开发
    + 基于组件的软件工程(CBSE)
+ 什么是CASE
  + CASE是计算机辅助软件工程的英文缩写，它包括很多种类的软件工具，这些工具覆盖面很广，包括支持软件过程活动，如需求分析、系统建模、调试、和测试等。
+ 优良软件的属性：
  + **可维护性**
    + 能够根据用户的需求不断进化
  + **可依赖性**
    + 可靠、保密、安全
  + **有效性**
    + 响应时间、处理时间、内存利用率
  + **可用性**
    + 简单易用
+ 软件工程面临问题：
  + 多样性的挑战
  + 交付上的挑战
  + 信任的挑战
+ 职业道德：
  + 保密
  + 工作能力
  + 知识产权
  + 计算机滥用

####	软件过程

##### 1.软件过程模型：

+ 瀑布模型
  + 需求分析和定义
  + 系统和软件设计
  + 实现和单元测试
  + 集成和系统测试
  + 运行和维护（非必须）
  + **缺点**：难以响应用户需求的变更
+ 进化式开发
  + 思想：先开发出一个原型系统给用户使用，通过用户的反馈意见来不断修改系统直到最后成熟。
  + 包括
    + 探索式开发：目标是和用户一起工作，共同探索需求
    + 抛弃式原型
+ 过程反复
  + 增量式开发：并行的瀑布模型
  + 螺旋式开发：
    + 目标设置：为项目的这个阶段定义专门目标
    + 风险评估和规避
    + 开发和有效性验证
    + 规划
+ 过程活动
  + **描述、开发、验证、进化**
  + 软件描述
    + 主要是理解并定义系统需要哪些服务，以及找出开发和运行期间受到哪些约束。需求工程对于软件工程是一个特别关键的阶段。
    + 需求工程的四个阶段：
      + **可行性研究**：指明现有软件、硬件技术能否实现用户对新系统的要求，并从业务角度来决定系统开发是否划算以及在预算范围之内能否开发得出来。研究之后给出可行性报告。
      + **需求导出和分析**：通过对现有系统分析、与潜在用户和购买者讨论、进行任务分析导出系统需求得过程。
      + **需求描述**：是把在分析活动中收集的信息以文档的形式确定下来。
      + **需求的有效性验证**：这个活动检查需求实现、一致性和完备性。
  + 软件设计和实现
    + 定义：把系统描述转换成一个可运行的系统的过程。
    + 设计：
      + 体系结构设计：确定系统是由哪些子系统构成的，以及这些子系统之间的关系是怎样的，并对这些内容编写文档
      + 抽象描述：对每个子系统提供的服务以及子系统在什么范围内运行给出抽象描述
      + 接口设计：对每个子系统，都要给出与其他子系统之间的接口设计并编写文档。
      + 组件设计：把服务分派到不同的组件，并设计这些组件的接口
      + 数据结构设计：详细设计系统实现阶段要使用的数据结构（可推至实现过程阶段）
      + 算法设计：详细设计服务将要采用的算法，并对此做出描述。（可推至实现过程阶段）
  + 软件的有效性验证
    + 组件（单元）测试
    + 系统测试：组件集成系统测试。
    + 接收测试：最后阶段的测试，用客户提供的真实数据测试系统
  + 软件进化：
    + 定义系统需求-->访问现有系统-->提出系统变更-->修改系统-->新系统





### 二、需求

#### 1.需求大致分为

+ 用户需求
+ 系统需求
  + 功能需求：包括对系统应该提供的服务、如何对输入做出反应以及系统在特定条件下的行为描述。在某些情况下，功能需求可能还需明确声明系统不应该做什么。
  + 非功能需求：对系统提供的服务或功能给出的约束，包括时间约束，开发过程的约束，标准等。非功能需求常用于整个系统。通常不在单个系统和服务中。
  + 领域需求：这是来自系统的应用领域的需求，反映了该领域的特点。它们也可能是功能需求或者非功能需求。
+ **功能需求**：
  + 功能需求描述系统所预期提供的功能或服务。取决于开发的软件类型，用户的需求等。
+ **非功能需求**：
  + 指的是那些不直接与系统具体功能相关的一类需求。它们与系统的总体特性相关，如可靠性、反应时间、存储空间等
+ **软件需求文档**：
  + 软件需求文档（SRS）是对系统开发者应当实现的内容的正式陈述。
  + IEEE标准
    + 1.引言
      + 1.1需求文档的目的
      + 1.2产品范围
      + 。。。
    + 2.一般描述
      + 2.1产品透视
      + 2.2产品功能
      + 2.3用户特征
      + 。。。
    + 3.专门需求
    + 4.附录



#### 2.需求工程过程

+ 目标：创建和维护系统需求文档

#### （1）可行性研究

+ 对于所有新的系统，需求工程过程都应该从可行性研究开始。可行性研究的输入信息是一系列初步需求、系统的一个框架描述和希望系统将如何支持业务过程的说明信息，可行性研究的结果应该是给出一份报告，对需求工程和系统开发过程是否值得进行给出具体的意见和建议。
+ 重点集中在回答以下问题：
  + 系统是否符合机构的总体目标？
  + 系统是否可能在现在的技术条件、预算和时间限制内完成？
  + 系统能否与已经存在的其他系统集成？
+ 进行一项可行性研究包括：
  + 信息评估
  + 信息汇总
  + 报告生成

#### （2）需求导出和分析

+ 在初始的可行性研究之后，下一个需求工程过程就是需求导出和分析。在这个活动中，软件开发技术人员要和客户及系统最终用户一起调查应用领域，即系统应该提供什么服务、系统应该具有什么样的性能以及硬件约束。
+ 活动过程：
  + **需求发现**：这是一个与系统的信息持有者交流从而收集他们的需求的过程。来自信息持
    有者和文档的领域需求也是在这个活动中得以发现的。
  + **需求分类和组织**：所收集的需求是无序的,需要对其重新组织和整理,将其分成相关的几
    个组。
  + **优先排序和冲突解决**：在有多个项目相关人员参与的地方,需求将难免会发生冲突。这
    个括动就是通过协商发现并解决这些冲突
  + **需求文档编制**：记录需求并将它作为螺旋下一循环的输人,产生形式化的或非形式化的
    需求文档。

#### （3）需求的有效性验证

+ 需求有效性验证是要检验需求能否反映客户的意愿。它和分析有很多共性,都是要发现需求
  中的问题。
+ **1.有效性检查**：某个用户可能认为系统应该执行某项功能。然而,经过进一步的思考和分
  析,可能发现还需要添加另一些功能,或是发现系统需要的是完全不同的功能。系统有很多用
  户,而这些用户可能需要不同的功能,因此,任何一组需求都不可避免地要在不同用户之间协商
+ **2.一致性检查**：在文档中,需求不应该冲突。即对同一个系统功能不应出现不同的描述或
  相互矛盾的约束。
+ **3.完备性检查**：需求文档应该包括所有系统用户想要的功能和约束
+ **4,现实性检查**：基于对已有技术的了解,检查需求以保证能利用现有技术实现。这些检查
  还要考虑到系统开发的预算和进度安排。
+ **5,可检验性检查**：为了减少在客户和开发商之间可能的争议,描述的系统需求应该总是可
  以检验的。这意味着能设计出一组检查方法来验证交付的系统是否满足需求。
+ **需求有效性验证技术**：
  + 需求评审
  + 原型建立
  + 测试用例生成

#### （4）需求管理

+ **1.需求管理规划**：规划在需求管理过程中是第一个基本阶段。需求管理是昂贵的,对每个项目,规划阶段都要建立需求管理所需细节的层次结构。在需求管理阶段,必须决定以下内容
  + **需求识别**：每个需求要有一个惟一的标识以便可以被其他需求交叉素引,同时可以用到
    可追溯的评估中
  + **变更管理过程**：这是一组对变更带来的影响和成本做评估的活动。
  + **可追湖策略**：这些策略定义了需求之间的关系以及需求和系统设计之间的关系,这些关
    系是要被记录下来的,对此要给出记录的维护方法。
+ **2.需求变更管理**
  + **问题分析和变更描述过程**
  + **变更分析和成本计算**
  + **变更实现**

------



#### 【项目开发计划书】

>**引言**
>
>1.编写目的
>
>​		阐明编写开发计划的目的，指明读者对象
>
>2.项目背景
>
>​		a.项目的委托单位、开发单位和主管部门
>
>​		b.该软件系统与其他系统的关系
>
>3.定义
>
>​		列出本文档中用到的专门术语的定义和缩写词的原文
>
>4.参考资料
>
>​		a.项目经核准的计划任务书、合同或上级机关的批文
>
>​		b.文档所引用的资料、规范等；列出这些资料的作者、标题、编号、发表日期、出版单位或资料来源。
>
>**项目描述**
>
>1.工作内容
>
>​			简要说明项目的各项主要工作，介绍所开发软件的功能、性能等。若不编写可行性研究报告，则应在本节给出较详细的介绍。
>
>2.条件与限制
>
>​			阐明为完成项目应具备的条件、开发单位已具备的条件以及尚需创造的条件。必要时还应说明用户及分合同承包者承担的工作、完成期限及其他条件与限制。
>
>3.产品
>
>3.1程序
>列出应交付的程序名称、使用的语言及存储形式
>
>3.2文档
>列出应交付的文档
>
>4.运行环境
>
>应包括硬件环境、软件环境、
>
>5.服务
>
>阐明开发单位可向用户提供的服务。如人员培训、安装、保修、维护和其他运行支持
>
>6.验收标准
>
>**实施计划**
>
>1.任务分配
>
>2.进度：按阶段完成的项目，用图表说明开始时间、完成时间
>
>3.预算
>
>​	大概需要的经费
>
>4.关键问题
>
>**人员组织及分工**
>什么时间，需要什么样的人，需要多少人
>
>**交付期限**
>总的交付期限
>每个阶段的交付期限
>
>**专题计划要点**
>如测试计划、质量保证计划、配置管理计划、人员培训计划、系统安装计划等
>
>



### 三、软件设计

#### 1.总体设计

<[软件工程——总体设计与详细设计 - 程序员大本营 (pianshen.com)](https://www.pianshen.com/article/73731372751/)>

<[(12条消息) 软件工程--总体设计_Hannah-CSDN博客_软件工程总体设计](https://blog.csdn.net/zhuanzhe117/article/details/8271041)>

+ **任务**：根据用户需求分析阶段得到的目标系统的逻辑模型确定一个合理的软件系统的体系结构**.**包括划分组成系统的模块**,**模块间的调用关系及模块间的接口关系**,**软件系统所用的数据结构或者数据库结构
  + 将系统划分成物理元素，即程序、文件、数据库和文档等。
  + 设计软件结构，即将需求规格转换为体系结构，划分出程序的模块组成、模块间的相互关系。确定系统的数据结构、文件结构、数据库模式，确定测试方法与策略。
  + 编写总体设计说明书、用户手册、测试计划，用结构图来描述软件结构，选择分解功能与划分模块的设计原则。
+ 从**技术的角度**，软件设计主要包括4方面内容
  + 体系结构：模块+模块
  + 通讯接口：供其他软硬件调用
  + 数据设计：侧重于数据结构的设计
  + 算法设计
  + 人机交互
+ 从工程角度考虑：
  + 概要设计和详细设计体现了“自顶向下，逐步细化”的设计原则
+ 软件体系结构的典型风格：
  + 主程序-子程序风格
  + 面向对象风格
  + 层次风格
  + 以数据为中心的风格（仓库风格）
  + 客户机-服务器体系结构风格

#### 2.详细设计

+ 结构化设计方法

  + 是一种面向数据流的设计方法

    + 主程序-子程序风格

  + 目标：通过对模块的合理划分，得到软件的体系结构图，进而对模块的合理划分，得到软件的体系结构图，进而再细化每个模块内部的处理流程。

  + 核心原则：模块化

  + 设计策略：分而治之

  + 模块化设计的优点：通过模块分解可降低系统复杂性，提高复用度（模块复用），使系统易于修改和维护，同时也有助于系统各部分之间的并行开发，提高软件开发效率。

  + 模块的独立性：模块独立性是软件系统划分模块时的一个主要准则，也是判断模块构造是否合理的主要标准之一。

    + 如果一个模块只完成一个相对独立的子功能（即功能单一），并且与其它模块之间没有过多的相互作用和复杂的联系（即与其它模块之间的接口是简单的），则称这样的模块具有独立性。

  + 通常从以下两方面来衡量模块的独立性：

    + 模块本身的内聚性
    + 模块之间的耦合性

  + **模块的内聚性**：

    + 内聚性是**从“功能”的角度来衡量模块内的联系**，是对模块功能强度的度量： 如果一个模块内部的所有成分，都是为了完成某个单一功能，而彼此紧密结合在一起，则说明该模块的内聚性强。

      + > ​											内聚性
        >
        > 高----------------------------------------------------------------------------------------低
        >
        > **功能内聚** | 顺序内聚 | 通信内聚 | 时间内聚 | **逻辑内聚** | 偶然内聚
        >
        > ​											模块独立性
        >
        > 强-----------------------------------------------------------------------------------------弱
        >
        > 功能单一																							功能分散

  + **模块的耦合性**：

    + 表示模块与模块之间相互联系、相互依赖的紧密程度。模块间连接越紧密，联系越复杂，耦合性越高。

    + 模块间相互关联的程度通常取决于：模块间相互联系的方式；模块间传递的信息量；模块间接口类型的复杂程度等。

      + > ​										耦合性
        >
        > 低-------------------------------------------------------------------------------------高
        >
        > ​         **数据耦合** | 标记耦合 |  控制耦合 | 公共耦合 | **内容耦合** 
        >
        > ​										模块独立性
        >
        > 强-------------------------------------------------------------------------------------低



### 四、软件测试

+ 定义：根据程序的内部结构和功能规格说明来设计测试用例，并利用这些测试用例运行程序，以发现程序中存在的错误和缺陷。

+ “错误群集”现象

  + 在测试中，对于已发现的错误数量较多的程序模块，其残留的错误数量也可能较多。即这些程序模块比其它模块有更多的错误倾向，从而产生 “错误群集” 现象。
  + 软件测试中，要充分注意 “错误群集” 现象，对于这样的程序模块应当进行重点测试，投入更多的测试工作量。

+ 常见测试方法分类（从是否需要执行被测程序角度划分）

  + 静态测试：人工检测
  + 动态测试：通过设计测试用例，在机器上运行被测程序。

+ 动态测试：

  + 黑盒测试：不考虑被测程序内部逻辑结构，只按照被测程序的功能规格说明来设计测试用例，以检查程序功能是否符合规格说明要求，也称为”功能测试“。
  + 白盒测试：根据被测程序的内部逻辑结构来设计测试用例，以检查程序内部的所有逻辑路径，也称为”结构测试“。

+ 软件测试过程：

  + 遵循”自底向上，逐步集成“的方式，即从小规模测试开始，逐步进行大规模测试

  + > 需求分析 --- 总体设计 --- 详细设计 --- 软件实现（编码）---  单元测试 --- 集成测试  --- 确认测试（软件需求）  ---  系统测试（系统其他元素）  ---  验收测试（用户参与）



+ 1.单元测试：
  + 测试对象：对每个程序模块进行正确性检验
  + 测试依据：以详细设计说明和源程序代码为依据
  + 测试方法：主要采用白盒测试方法
  + 单元测试环境：可以用驱动模块和桩模块来模拟与被测模块相关联的其它模块，从而构成被测模块的单元测试环境
    + 驱动模块：调用被测模块的模块
    + 桩模块：被测模块调用的模块
+ 2.集成测试：
  + 测试对象：按照软件体系结构的要求，将各个模块通过接口连接在一起，检查所构成的子系统能否正确运行
  + 测试依据：概要设计说明和详细设计说明
  + 集成测试主要方法：
    + 一次性集成
    + 渐增性集成
      + 自顶向下渐增性集成
      + 自底向上渐增性集成
      + 三明治式渐增性集成
+ 3.确认测试
  + 有效性测试
    + 检查集成后的软件系统在功能和性能上是否满足需求规格说明中所确认的标准，即检查软件系统与用户需求是否一致。
    + 测试依据：以需求规格说明为依据
    + 测试方法：主要采用黑盒测试方法
  + 软件配置审查
    + 检查各种软件文档（包括需求文档、设计文档、源程序代码清单、测试文档等）是否完整正确。
    + 目的是保证与软件开发有关的所有文档都完整、齐全，便于后期维护阶段使用。
+ 4.黑盒测试用例设计
  + 将被测程序的输入域划分成若干个**等价类**，在每个**等价类**中选取一些代表性数据作为测试用例，即用**少量的代表性输入数据**来代替整个输入域。
    + 输入域：对于被测程序来说，所有输入数据组成的完整集合
    + 等价类：输入域中的一个子集，在该子集中所包含的输入数据对于揭露程序错误都是等效的。
    + 等价类法：
      + 有效等价类
      + 无效等价类
    + 边界值分析法：
      + 边界值分析法是等价类划分法的补充。通常，两种方法相结合使用
      + 根据等价类的边界条件来设计测试用例。即在等价类的边界处选取数据作为测试用例，而不是在等价类内部选取典型值。
    + 因果图法：
      + 被测程序的输入条件称为“因”，输出结果称为“果”
      + 因果图：用来表达输入条件的各种取值组合情况与输出结果之间的对应关系。
      + 该方法主要检查被测程序在输入条件的各种取值组合情况下，是否能够产生正确的输出结果。
+ 5.白盒测试用例设计
  + 白盒测试用例中的输入数据从程序内部的逻辑结构导出，但预期输出是从程序的功能规格说明中导出
  + 白盒测试考虑测试用例**对程序内部执行路径的覆盖程度**。
  + 1.条件覆盖法：五种覆盖标准（程度由弱到强）
    + 语句覆盖：至少每条语句都执行一次
    + 判定覆盖（也称分支覆盖）：每个判定的每个分支（真分支和假分支）都至少执行一次
    + 条件覆盖：每个判定语句中的每个条件，分别按”真“和”假“都至少执行一次。
    + 判定-条件覆盖：**被测程序同时满足判定覆盖和条件覆盖的要求。**
    + 条件组合覆盖：使被测程序中每个判定中所有的**条件取值组合**都至少执行一次
  + 2.基本路径测试法：使用该方法设计测试用例时，以**程序控制流图**为基础，计算被测程序的**环路复杂度V**，进而定义出被测程序的一个**基本路径集合**（由一系列的**独立路径**组成），最终导出测试用例，使得每个测试用例覆盖一条独立路径

### 五、面向对象

+ 与传统结构化方法的对比

  + > 面向对象分析 OOA <--------------->  结构化分析SA
    >
    > 面向对象设计 OOD <---------------> 结构化设计SD
    >
    > 面向对象编程 OOP <----------------> 结构化编程SP

+ 面向对象软件开发过程模型——喷泉模型

  + 面向对象开发过程中，各阶段之间形成频繁的迭代
  + 各阶段均采用统一的“对象”概念，使得各阶段之间形成**“无缝”连接**。

#### 软件工程中对”面向对象“的基本概念：

+ 软件工程中对“面向对象”的定义：**面向对象=对象+类+继承+消息通信**



+ 类间关系
  + 泛化（继承）：用实线空心三角箭头表示
  + 组成关系：
    + 聚合：整体类对象与部分类对象在生命周期上是相互独立的（即当整体类对象不存在了，部分类对象仍旧可以独立存在），用实线空心菱形箭头表示
    + 组合：整体类对象与部分类对象具有同样的生命周期（即当整体类对象不存在了，部分类对象也将不存在），用实线实心菱形箭头表示
  + 关联关系：实现表示
  + 依赖关系：虚线表示
    + 依赖关系也可视为对象之间的一种使用关系，这种使用关系是临时性的，而非长期存在的。
    + 一个类是另一个类的某个操作（或方法）的参数。
    + 一个类在另一个类的某个操作（或方法）中被使用。 
  + 类间关系强度：
    + 继承> 组合 > 聚合 > 关联 > 依赖
+ 面向对象分析（OOA）
  + 用例图：
  + 类图：描述系统的概念实体
  + 泳道图
  + 时序图：描述对象之间的交互行为
+ 从用例模型入手，识别**分析类**：
  + 边界类（Boundary Class）
    + 用于描述系统外部的角色与系统之间的**交互接口**。
    + 目的：**将用例内部的执行逻辑与外部环境进行隔离**，使得外界环境的变化不会影响到内部的逻辑部分。
    + 三种类型：用户界面、软件系统接口、硬件设备接口
  + 控制类（Control Class）
    + 描述用例所具有的事件流的执行逻辑。控制类本身不处理具体的任务，而是调度其它类来完成具体任务。
  + 实体类（Entity Class）
    + 通常对应现实世界中的“事物”。这些“事物”的基本信息及其相关行为需要在系统中长期存储和管理。

### 六、软件维护

+ 定义：
  + 软件在交付给用户使用之后，为了修改软件错误或满足需求变化而变更软件的过程。以保证软件可以长期处于可用状态，并能够适应实际业务的不断变化。
+ 主要分为三种主要的维护类型：
  + 改正性维护
  + 适应性维护
  + 完善性维护
+ 软件维护
  + 结构化维护
    + 采用软件工程方法进行软件开发，保证每个阶段都有详细的文档，维护工作则相对容易，称为结构化维护。
  + 非结构化维护
    + 不采用软件工程方法开发软件，软件只有程序而欠缺文档，则维护工作会很困难，称为非结构化维护
+ 软件的可维护性：是指维护人员进行软件维护活动时的难易程度。
  + 可理解性
  + 可测试性
  + 可修改性
  + 可靠性
  + 可移植性
  + 可重用性
  + 效率
+ 可靠性：是指软件在达到用户要求和设计目标的基础上，在给定的时间间隔内能够正确、无故障运行的概率。
  + **平均无故障时间（MTBF）**
  + **平均修复时间（MTTR）**

