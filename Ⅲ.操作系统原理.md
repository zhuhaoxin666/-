### 一、操作系统概述

定义：操作系统是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。主要作用是管理好这些设备，提高它们的利用率和系统的吞吐量，并为用户和应用程序提供一个简单的接口，便于用户使用。



**定义**：**操作系统是一组能有效地组织和管理计算机硬件和软件资源，合理地对各类作业进行调度，以方便用户使用的程序的集合。**

+ 操作系统的目标
  + 方便性
  + 有效性
    + 提高系统资源的利用率
    + 提高系统的吞吐量
  + 可扩充性
  + 开放性
+ 操作系统的作用
  + OS作为**用户与计算机硬件系统之间的接口**
  + OS作为**计算机系统资源的管理者**
    + 处理机管理
      + **分配和控制处理机**
    + 存储器管理
      + **内存的分配和回收**
    + I/O设备管理
      + **I/O设备的分配（回收）与操纵**
    + 文件（数据和程序）管理
      + **对文件的存取、共享和保护**
  + OS实现了对**计算机资源的抽象**
+ 推动操作系统发展的主要动力
  + 不断提高计算机资源利用率
  + 方便用户
  + 器件的不断更新迭代
  + 计算机体系结构的不断发展
  + 不断提出新的应用需求
+ 操作系统的发展过程
  + 未配置操作系统的计算机系统
    + 人工操作模式
    + 脱机输入/输出方式：通过外围机和磁带，事先将程序和数据装入磁带，CPU需要这些数据时，再从磁带上高速的调入内存。
      + 目的：为了解决人机矛盾及CPU和I/O设备之间速度不匹配的矛盾
      + 优点：
        + 减少了CPU的空闲时间
        + 提高I/O速度
  + 单道批处理系统：内存中始终只保持一道作业，在处理完一个作业后，紧接着处理下一个作业，以减少机器的空闲等待时间。
    + 旨在解决人机矛盾和CPU与I/O设备速度不匹配，提高系统资源利用率和系统吞吐量。
    + 缺点：
      + 系统中的资源得不到充分的利用。因为内存中仅有一道程序。
        + CPU利用率低
        + 内存利用率低
  + **多道批处理系统**
    + 定义：用户提交的作业先存放在外存，并排成一个队列。之后由作业调度程序按一定算法，从队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。
    + 优点：
      + 资源利用率高
      + 系统吞吐量大
    + 缺点：
      + 平均周转时间长
      + 无交互能力
  + **分时系统**
    + 人—机交互
    + 共享主机
    + 实现中的关键问题
      + 及时接收
        + 多路卡扫描各个终端的命令
      + 及时处理
        + 作业直接进入内存。因为作业在磁盘上是不能运行的。
        + 采用轮转运行方式。
    + 分时系统的特征：
      + 多路性：多个用户共享一台主机
      + 独立性：多个用户之间彼此互不干扰
      + 及时性：
      + 交互性：
  + **实时系统**
    + 定义：指系统能及时响应外部时间的请求，在规定时间内完成对该时间的处理，并控制所有实时任务协调一致的运行。
    + 实时系统类型
      + 工业（武器）控制系统
      + 信息查询系统
      + 多媒体系统
      + 嵌入式系统
    + 实时任务类型
      + 周期性实时任务和非周期性实时任务
      + 硬实时任务和软实时任务
    + 特点
      + 多路性
      + 独立性
      + 及时性
      + 交互性
      + 可靠性
    + 微机操作系统的发展
      + 单用户单任务操作系统
      + 单用户多任务操作系统
      + 多用户多任务操作系统
  + **操作系统的基本特性**
    + **并发**
      + 目的：提高系统中的资源利用率，增加系统的吞吐量
      + **并行与并发**
        + 并行性是指两个或多个事件在同一时刻发生。而并发性是指两个或多个事件在同一时间间隔内发生。
    + **共享**
      + 互斥共享（打印机、磁带机等）
        + 临界资源：在一段时间内只允许一个进程访问的资源
      + 同时共享（磁盘）
    + **虚拟**
      + 定义：通过某种技术将一个物理实体变成若干个逻辑上的对应物的功能称为“虚拟”。
      + **时分复用**：利用某设备为一用户服务的空闲时间，又转去为其他用户服务，使设备得到最充分的利用。
        + 虚拟处理机技术
        + 虚拟设备技术
      + **空分复用**
        + 虚拟存储
    + **异步**
  + **操作系统的主要功能**
    + **处理机管理功能**
      + 进程控制
      + 进程同步
        + 最常用：信号量机制
      + 进程通信
      + 调度
        + 作业调度
        + 进程调度
    + **存储器管理功能**
      + 内存分配
        + 静态分配
        + 动态分配
      + 内存保护
        + 确保每道用户程序都仅在自己的内存空间内运行，彼此互不干扰
        + 绝不允许用户程序访问程序访问操作系统的程序和数据
      + 地址映射
        + 在硬件的支持下，将地址空间中的逻辑地址转换为内存空间中与之对应的物理地址。
      + 内存扩充
        + 虚拟内存
          + 请求调入
          + 页面置换
    + **设备管理**
      + 主要任务
        + 完成用户进程提出的I/O请求，为用户分配所需的I/O设备，完成指定的I/O操作
        + 提高CPU和I/O设备的利用率
      + **缓冲管理**：缓和CPU和I/O设备的速度不匹配矛盾，提高CPU的利用率，进而提高系统吞吐量。
        + 单缓冲机制
        + 能实现双向同时传送数据的双缓存机制
        + 能供多个设备同时使用的公共缓冲池机制
      + **设备分配**
      + **设备处理**
        + 基本任务：实现CPU和设备控制器之间通信，即由CPU向设备控制器发出I/O命令，要求它完成指定的I/O操作；反之，由CPU接收从控制器发来的中断请求，并给予迅速的响应和相应的处理。
    + **文件管理**
      + 主要任务：对用户文件和系统文件进行管理以方便用户使用，并保证文件的安全性。
      + **文件存储空间的管理**
      + **目录管理**
        + 为每个文件建立一个目录项
          + 目录项
            + 文件名
            + 文件属性
            + 文件在磁盘上的物理位置
      + **文件的读/写管理和保护**
  + 操作系统与用户之间的接口
    + 用户接口
      + 命令接口
        + 联机命令接口：交互式，如命令终端
        + 脱机命令接口：批处理作业，如bat文件
        + GUI（图形用户接口）
    + 程序接口
      + 系统调用
  + 现代操作系统的新功能
    + 系统安全
      + 认证技术
      + 密码技术
      + 访问控制技术
      + 反病毒技术
    + 网络功能和服务
      + 网络通信
      + 资源管理
      + 应用互操作
    + 支持多媒体



### 二、进程管理

#### 1. 进程的描述与控制

+ 程序顺序执行的特征

  + 顺序性
  + 封闭性
  + 可再现性：debug

+ 程序并发执行的特征

  + 间断性
  + 失去封闭性
  + 不可再现性

+ **进程的描述**

  + **PCB（进程控制块）**：为了使参与并发执行的每个程序（含数据）都能独立地运行，在操作系统中必须为之配置一个专门的数据结构，称为进程控制块。
  + 由**程序段**，**相关的数据段**，**PCB**三部分构成了**进程实体（进程映像）**。
  + 创建进程就是创建PCB，撤销进程就是撤销PCB
  + 进程典型定义：
    + 进程是程序的一次执行
    + 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
    + **进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。**
  + 进程的**特征**：
    + **动态性**
    + **并发性**
    + **独立性**
    + **异步性**

+ 进程的基本状态及转换

  + **就绪**

  + **执行**

  + **阻塞**

  + **创建**

  + **终止**

  + 引入**挂起(Suspend)**和**激活(Active)**

    + 活动就绪--->静止就绪：未被挂起的就绪程序，称为活动就绪，表示为Readya。用Suspend原语挂起之后，便转为静止就绪，表示为Readys，
    + 活动阻塞--->静止阻塞：当期待的事件出现之后，它将从静止阻塞变为静止就绪Readys状态

    + 静止就绪---->活动就绪：用active原语激活
    + 静止阻塞---->活动阻塞：用active原语激活

+ 进程管理中的数据结构

  + **进程控制块PCB的作用**
    + 作为独立运行基本单位的标志
    + 能实现间断性运行方式
    + 提供进程管理所需要的信息
    + 提供进程调度所需要的信息
    + 实现与其他进程的同步与通信
  + **进程控制块中的信息**
    + 进程标识符
      + 外部标识符
      + 内部标识符
    + 处理机状态
      + 处理机状态信息也称为处理机的上下文，主要是由处理机的各种寄存器中的内容组成的。
      + 这些寄存器包括
        + 通用寄存器
        + 指令计数器
        + 程序状态字PSW
        + 用户栈指针
    + 进程调度信息
      + 进程状态
      + 进程优先级
      + 调度所需的其他信息
      + 事件
    + 进程控制信息
      + 程序和数据地址
      + 进程同步和通信机制
      + 资源清单
      + 链接指针
  + 进程控制块的组织方式
    + 线性方式
    + 链接方式
    + 索引方式

+ **进程控制**

  + **是进程管理中最基本的功能，主要包括创建新进程、终止已完成的进程、阻塞进程、恢复就绪等**
  + 操作系统内核：
    + 支撑功能
      + 中断处理
      + 时钟管理
      + 原语操作
    + 资源管理功能
      + 进程管理
      + 存储器管理
      + 设备管理
  + **进程创建**
    + （1）申请空白PCB
    + （2）为新进程分配其运行所需的资源
    + （3）初始化进程控制块
      + 初始化标识信息
      + 初始化处理机状态信息
      + 初始化处理机控制信息
    + （4）置入就绪队列（就绪队列未满时）
  + **进程终止**
    + 引起进程终止的事件
      + 正常结束
      + 异常结束
        + 越界
        + 保护：比如写一个只读文件
        + 非法指令
        + 特权指令错：无权限
        + 运行超时
        + 等待超时
        + 算数运算错
        + I/O故障
      + 外界干预
        + 操作员或操作系统干预
        + 父进程请求
        + 父进程终止
    + 进程的终止过程
      + OS调用终止原语
      + 根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从而读出该进程的状态。
      + 执行状态停止
      + 结束子孙进程
      + 归还资源给父进程或操作系统
      + 将被终止进程（PCB）从所在队列中移出

+ 进程的**阻塞与唤醒**

  + 引起阻塞和唤醒的事件
    + 向系统请求共享资源失败
    + 等待某种操作的完成
    + 新数据尚未到达
    + 等待新任务的到达
  + 进程阻塞过程
    + 执行状态--->>>停止
    + 将PCB插入阻塞队列
    + 调度其他就绪程序
  + 进程唤醒过程
    + 将唤醒的进程从阻塞队列中移除
    + 将其PCB中的现行状态由阻塞改为就绪
    + 将该PCB插入到就绪队列中
  + 进程的挂起与激活
    + 挂起
      + 检查被挂起进程的状态
      + 若处于活动就绪，则改为静止就绪
      + 若处于活动阻塞，则改为静止阻塞
      + 若正在执行，则转向调度程序调度其他就绪程序
    + 激活
      + 首先将进程从外存调入内存，检查现行状态
      + 若是静止就绪，则改为活动就绪
      + 若是静止阻塞，则改为活动阻塞
      + 如果是抢占调度策略，检查被激活的进程的优先级，若被激活的进程优先级低则不用重新调度。否则，立即剥夺当前进程的运行，把处理机分配给刚刚激活的进程。

+ **进程同步**

  + 同步机制应遵循的规则

    + 空闲让进
    + 忙则等待
    + 有限等待
    + 让权等待

  + **硬件同步机制**

    + 关中断：在进入锁测试之前关闭中断，直到完成锁测试并上锁之后才能打开中断
    + 利用Test-and-Set指令互斥
    + Swap指令：在Intel 80x86中为XCHG指令

  + **信号量机制**

    + 整型信号量

      + wait  **P**
      + signal **V**

    + 记录型信号量

      + 解决整型信号量的忙等问题

      + ```c
        typedef struct {
            int value;
            struct process_control_block *list;
        }semaphore;
        
        wait(semaphore *S){
            S->value--;
            if(S->value<0)
                block(S->list);
        }
        
        signal(semaphore *S){
            S->value++;
            if(S->value<=0)
                wakeup(S->list);
        }
        
        ```

    + AND型信号量

      + 目的：解决多个临界资源时的进程同步
      + 基本思想：将进程在整个运行过程中需要的所有资源，一次性全部分配给进程，待进程使用完之后再一起释放。

    + 信号量集

  + **管程机制**

  + **进程通信**

    + 共享存储器系统
    + 管道（pipe）通信系统
      + 管道文件
    + 消息传递系统
      + 通过OS的原语
    + 客户机-服务器系统
      + 套接字（Socket）
        + 远程过程调用和远程方法调用

+ **线程**

  + 目的：减少程序在并发执行时所付出的时空开销，提高并发

  + **特点**

    + 调度的基本单位

    + 并发性：同一个进程中的线程可并发，不同进程中的线程也可并发

    + 进程可拥有系统资源，线程仅拥有本身能保证独立运行的资源。比如线程控制块TCB，程序计数器，保留局部变量，少量状态参数，返回地址等

    + 独立性：比进程独立性低得多

    + 系统开销小

    + 支持多处理机系统

      

+ **处理机调度与死锁**

  + 处理机调度算法的共同目标
    + 资源利用率
      + CPU的资源利用率 = CPU有效工作时间 / （CPU有效工作时间 + CPU空闲等待时间）
    + 公平性
    + 平衡性
    + 策略强制执行
  + 批处理系统的目标
    + 平均周转时间短
    + 系统吞吐量高：吞吐量—单位时间内系统所完成的作业数
    + 处理机利用率高
  + 分时系统的目标
    + 响应时间快
    + 均衡性
  + 实时系统的目标
    + 截止时间的保证
    + 可预测性
  + **先来先服务和短作业优先调度算法**
    + 先来先服务（First come ，First served）
    + 短作业优先 （Short Job First）
      + 以作业运行时间来衡量作业的长短
      + 缺点
        + 必须预知作业的运行时间
        + 对长作业非常不利
        + 不能兼顾作业的紧迫程度
  + **优先级调度算法和高响应比优先调度算法**
    + 优先级调度算法
      + 由外部赋予作业响应的优先级，调度算法根据优先级来调度
    + 高响应比优先调度算法
      + 兼顾等待时间和运行时间
      + 优先权= (等待时间+要求服务时间) / 要求服务时间
      + **响应比 Rp = (等待时间 + 要求服务时间) / 要求服务时间 = 响应时间 / 要求服务时间**
  
+ **进程调度**

  + 进程调度的**任务**
    + 保存处理机的现场信息
    + 按某种算法选取进程
    + 把处理器分配给进程
  + 进程调度**方式**
    + 非抢占式
      + 实现简单，系统开销小，适用于大多数批处理系统
      + 不能用于分时系统和大多数实时系统
    + 抢占方式
      + 原则：
        + 优先权原则
        + 短进程优先原则
        + 时间片原则
  + 轮转调度算法（RR）
    + 时间片大小的确定
      + 若选择很小的时间片，将有利于短作业，但会导致频繁的进程调度和进程上下文切换，增加系统开销。
      + 若时间片选得太长，RR算法就退化成了FCFS算法，无法满足短作业和交互式用户的要求
      + **完成时间**：根据时间片和任务来算
      + **周转时间**：完成时间 - 到达时间
      + **带权周转时间**：周转时间 / 服务时间
  + 优先级调度算法
    + 类型
      + 非抢占式优先级调度算法
      + 抢占式优先级调度算法
    + 优先级类型
      + 静态优先级
      + 动态优先级
  + 多队列调度算法
  + 基于公平原则的调度算法
    + 保证调度算法
    + 公平分享调度算法

+ **死锁**

  + 竞争不可抢占性资源引起死锁

  + 竞争可消耗资源引起死锁

  + 进程推进顺序不当引起死锁

  + **定义**

    + 在一组进程发生死锁的情况下，这组死锁进程中的每一个进程，都在等待另一个死锁进程所占有的资源。

  + **产生死锁的必要条件**

    + **互斥**
    + **请求与保持**
    + **不可抢占**：进程已经获得的资源在未使用完之前不能被抢占
    + **循环等待条件**

  + **处理死锁的方法**

    + **预防死锁**

      + 较易实现，通过设置某些限制条件，去破坏四个必要条件中的一个或多个条件
      + **主要破坏四个条件的后三个**
        + **破坏“请求和保持”条件**：系统必须做到：当一个进程在请求资源时，它不能持有不可抢占资源
          + 第一种协议：所有进程在开始运行之前，必须一次性地申请让其在整个运行过程中所需地全部资源
            + 缺点：
              + 资源严重浪费
              + 使进程经常会发生饥饿现象
          + 第二种协议：对一种协议的改进，允许一个进程只获得运行初期所需的资源，便开始运行。进程运行过程中再逐步释放已分配给自己的、且已用毕的全部资源。
        + **破坏不可抢占条件**
          + 当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的资源
          + 实现复杂，且需要付出较大的代价
        + **破坏循环等待条件**
          + 对系统所有资源类型进行线性排序，并赋予不同的序号。规定每个进程必须按序号递增的顺序请求资源。已得到序号高的资源的进程若想请求序号低的资源，则必须先释放目前自己保持的资源。

    + **避免死锁**

      + 同样是事先预防策略，但不是事先采取各种限制措施，去破坏产生死锁的四个条件。而是在资源动态分配过程中，**用某种方法防止系统进入不安全状态。**

      + **银行家算法**

        + | Available 可利用资源 | Max 最大需求 | Allocation 分配 | Need 需求 |
          | -------------------- | ------------ | --------------- | --------- |
          |                      |              |                 |           |

        + need = max - allocation

        + work = available

        + | work | allocation | need | work + allocation | T OR F |
          | ---- | ---------- | ---- | ----------------- | ------ |
          |      |            |      |                   |        |

        + 若再添加请求，如P1 request（1，0，1）

          + 先判断（1，0，1） <= need 并且 (1,0,1) <= available
          + 否则处于不安全状态
          + 之后need = need - request（1，0，1）
          + available = available - request（1，0，1）
          + allocation = allocation + request（1，0，1）

    + **检测死锁**

      + 简化资源分配图，如不可简化，则死锁。（死锁定理）

    + **解除死锁**

      + 抢占资源
      + 终止进程

### 三、存储管理

#### 1.存储器的多层结构

+ > ​            寄存器
  >
  > ​           高速缓存
  >
  > ​		   主存储器
  >
  >  		  磁盘缓存
  >
  > ​			固定磁盘
  >
  > ​			可移动存储介质

#### 2.程序的装入和链接

+ 用户程序要在系统中运行，必须先将它装入内存，然后再将其转变为一个可执行的程序。通常需要以下步骤：
  + **编译**：由编译程序对用户源程序进行编译，形成若干个目标模块
  + **链接**：由链接程序将编译后形成的一组目标模块以及它们所需要的库函数链接在一起，形成完整的装入模块。
  + **装入**：由装入程序将装入模块装入内存。
  
+ 程序的装入
  + 绝对装入方式
  + 可重定位装入方式
  
+ 程序的链接
  + 静态链接方式
  + 装入时动态链接
  + 运行时动态链接
  
+ 连续分配存储管理
  + 单一连续分配
  + 固定分区分配
  
+ **基于顺序搜索的动态分区分配算法**
  + **首次适应算法（first fit，FF）**
    + 从低地址开始搜索，直到找到一个能够满足要求的空闲分区为止。
      + 能够为大作业留出高地址空间
      + 容易造成碎片
      + 每次查找都从低地址开始，开销大
  + **循环首次适应（next fit，NF）**
    + 每次搜索时不再是从低地址开始，而是从上次搜索的下一分区开始。
      + 减少了查找可用分区的开销
      + 会缺乏大的空闲空间
  + **最佳适应（best fit，BF）**
    + 将所有的空闲分区按从小到大排序，每次为作业分配内存时，总是能把满足要求，又是最小的空闲分区分配给作业，避免大材小用。
      + 碎片多
  + **最坏适应（worst fit，WF）**
    + 总是选择一个最大的空闲分区进行分配。将空闲分区从大到小排序，每次只要查看第一个分区能否满足要求即可。
      + 碎片可能性最小，对中小作业有利
      + 查找效率高
  
+ **基于索引搜索的动态分区分配算法**
  + 基于顺序搜索的动态分区算法，比较适用于不太大的系统。当系统很大时，系统的内存分区会很多。相应的空闲分区链就会很长，采用顺序搜索分区方法可能会很慢。基于索引搜索的动态分区分配算法能解决搜索空间慢的问题。
  + **快速适应（quick fit）**
    + **又称分类搜索法**，将空闲分区根据其容量大小进行分类，对每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这样系统中存在多个空闲分区链表。同时，在内存中设立一张管理索引表，其中的每一个索引表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针。空闲分区的分类是根据进程常用的空间来进行划分的，如2kb，4kb，8kb
    + 搜索时分两步：
      + 根据进程的长度，从索引表中去寻找能够容纳它的最小空闲分区链表
      + 从链表中取下第一块分配即可
    + 优点
      + 能保留大的分区
      + 不产生内存碎片
      + 查找效率高
    + 缺点
      + 分区归还主存合并时算法复杂，系统开销大。
      + 典型的以空间换时间的做法。
  + **伙伴系统（buddy system）**
    + 把所有的内存空间以大小均为2的k次幂划分。对于具有相同大小的所有空闲分区，单独设立一个空闲分区双向链表，这样不同大小的分区形成了k个空闲分区链表。
    + 例如，我需要分配一个长度为8的内存空间，则在空闲分区大小为8的空闲分区链表中查找，若找到则分配。若未找到，则到分区大小为16的空闲分区链表中查找，若存在，将该空间等分为两份，称为伙伴，其中一个用于分配，另一个加入分区大小为8的空闲分区链表。若不存在大小为16的空闲分区，继续寻找分区大小为32的空闲分区链表，若存在，第一次分割出两块大小为16的空闲空间，一块用于分配，一块用于加入空闲分区大小为16的链表，分配的哪一块继续分割出两块大小为8的空闲空间，一块用于分配，一块用于加入空闲分区大小为8的空闲空间。
    + 在最坏条件下，可能要对2^k的空闲分区进行k次分割才能得到所需分区。
    + 一次分割可能需要多次分割，一次回收可能也需要多次合并。
    + **性能**：
      + 时间性能低于快速适应，优于顺序搜索
      + 空间性能优于快速适应，略差于顺序搜索
    + **当前操作系统中，普遍采用的是分段分页式虚拟内存机制**
    + 但在多处理机系统中，伙伴算法仍被广泛使用。
  + **哈希算法**
  
+ **动态可重定位分区分配**
  + **紧凑**
  + **对换**
  
+ **分页存储管理方式**

  + **分页存储管理**：将用户程序地址空间分为若干个固定大小的区域，称为页或物理块。
  + **分段存储管理**：将用户空间分成若干个大小不同的段，存储器分配时以段为单位。
  + **段页式存储管理**：分页和分段结合，目前广泛使用。
  + **分段和分页的主要区别**
    + 页是信息的物理单位，对用户透明，提高内存的利用率。段是信息的逻辑单位，为了满足用户需求。
    + 页的大小固定，段的大小不固定。
    + 页地址是单一的线性地址，只需利用一个记忆符号即可表示一个地址。而段地址是二维的，既需要给出段名，又需要给出段内地址。
    + 分段易于实现信息共享

+ **段页式存储管理**

  + 段号-段内页号-页内地址

+ **虚拟存储器**

  + **特征**
    + 多次性
    + 对换性
    + 虚拟性
  + **缺页率**
    + 受以下因素影响
      + 页面大小，页面划分越大，缺页率越低
      + 进程所分配的物理块的数目，所分配的物理块数目越多，缺页率越低
      + 页面置换算法。
      + 程序固有特性。程序的局部化程度越高，相应执行时的缺页程度越低。
  + **页面置换算法**
    + **最佳置换算法**
    + **先入先出页面置换算法**
    + **最近最久未使用(LRU)**
    + **最少使用置换算法(LFU)**

  

  ### 四、设备管理

  + **磁盘访问时间**
    + 寻道时间
    + 旋转延迟时间
    + 传输时间
  + **早期的磁盘调度算法**
    + **先来先服务**
    + **最短寻道时优先**
  + **基于扫描的磁盘调度算法**
    + **（扫描算法）电梯调度算法SCAN**
    + **循环扫描算法CSCAN**
    + **NStepSCAN**：将磁盘请求队列分为若干个长度为N的子队列，磁盘按FCFS处理子队列，子队列按SCAN算法处理，**避免磁臂黏着**。
    + **FSCAN**：NStepSCAN的简化，将N的子队列变为2个。



### 五、文件管理

+ 文件和文件系统
  + 数据项
  + 记录
  + 文件：**文件是指由创建者定义的，具有文件名的一组相关元素的集合，分为有结构文件和无结构文件**
    + 文件类型：
      + 按用途
        + 系统文件
        + 用户文件
        + 库文件
      + 按数据形式
        + 源文件
        + 目标文件
        + 可执行文件

